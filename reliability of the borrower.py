#!/usr/bin/env python
# coding: utf-8

# <font color='blue'> Привет!) Поздравляю с первым самостоятельным проектом. Ты проделал большую работу. Далее в файле ты можешь найти мои комменатрии, выделенные синим. Пожайлуста, постарайся учесть их в дальнейших проектах.</font>

# ## Исследование надёжности заёмщиков
# 
# Заказчик — кредитный отдел банка. Нужно разобраться, влияет ли семейное положение и количество детей клиента на факт погашения кредита в срок. Входные данные от банка — статистика о платёжеспособности клиентов.
# 
# Результаты исследования будут учтены при построении модели **кредитного скоринга** — специальной системы, которая оценивает способность потенциального заёмщика вернуть кредит банку.

# ### Шаг 1. Откройте файл с данными и изучите общую информацию. 

# In[3]:


import pandas as pd
from pymystem3 import Mystem
from collections import Counter
#from math import abs
data=pd.read_csv('/datasets/data.csv')

data.head(30)


# ### Вывод

# Таблица содержит 12 столбцов и 21525 строк c типом данных в скобках:
#     
#     -children — количество детей в семье (int64)
#     -days_employed — общий трудовой стаж в днях (float64)
#     -dob_years — возраст клиента в годах (int64)
#     -education — уровень образования клиента (object)
#     -education_id — идентификатор уровня образования (int64)
#     -family_status — семейное положение (object)
#     -family_status_id — идентификатор семейного положения (int64)
#     -gender — пол клиента (object)
#     -income_type — тип занятости (object)
#     -debt — имел ли задолженность по возврату кредитов (int64)
#     -total_income — ежемесячный доход (float64)
#     -purpose — цель получения кредита (object)
# 
# Количество значения в столбцах days_employed и total_income говорит о том, что есть пропуски, которые нужно устранить и понять причину их появления.
# 
# Каждая строка данных содержит в себе информацию том, какой пол, возраст (в годах), его семейное положение, количество детей, трудовой стаж в днях, ежемесячный доход, уровень образования, тип занятости и информация о цели кредита и задолжности по возврату кредитов.
# Проблемы, которые надо решить- это пропуски Nan с данные в столбке days_employed и total_income (количество строк одинаковое). Возможно есть связь в источнике возникновения пропуска), элементы в столбце education привезти к одному регистру. Также встречаются значения с ссылкой.
# Основные показатели для работы с гипотизей- это количество детей в семье, семейное положение, наличие задолженности по возврату кредита и доход.

# <font color='blue'>Хороший анализ сырых данных. </font>

# ### Шаг 2. Предобработка данных

# ### Обработка пропусков

# In[3]:


data[data['days_employed'].isnull()].head(10) # 10 значений столбца [days_employed] c пропуском


# In[4]:


data[data['days_employed'].isnull()].count() # количество пропущенных (Nan) значений


# В 2174 из 21525 строках пропущено значение о трудовом стаже в днях в столбце ['days_employed'].

# <font color='blue'>Конечно удалить строки с пропусками это вариант, но не очень хороший. Что мешало заполнить их медианным значением? А так ты удалил 10% - это на грани, удалят больше 10% не рекомендуется никогда.</font>

# ## По замечанию исправление ниже

# In[5]:


#data=data.dropna().reset_index(drop=True)
median_income_type=data.groupby('income_type')['total_income'].transform('mean')
median_income_type_m=data.groupby('income_type')['total_income'].mean()
#data['total_income'].fillna(data.loc[data['income_type']=='пенсионер']['total_income'].median()).head(30)
#data['totlal_new']=data['total_income'].fillna(data.groupby('income_type')['total_income'].mean())


# In[6]:


median_income_type_m # Series data со средним доходом сгруппированных данных доход-род деятельности 


# In[7]:


median_income_type # Series data по всей таблице со средними значениями дохода в завасимости от рода деятельности


# In[8]:


data['total_income'].fillna(median_income_type, inplace=True)# заменяем nan на средние значения 


# In[9]:


data.head(30)


# Произведены замены Nan в столбце доход по среднему доходу в группе доход-род деятельности.

# In[10]:


data.info()


# In[11]:


data['days_employed'].isnull().sum() # количество пропусков в таблице


# In[12]:


del data['days_employed']# решил просто удалить, так как этот столбец не нужен для анализа


# In[13]:


data.columns


# In[14]:


data.isna().sum()# Проверка на пропуски


# ## Конец исправления по замечанию

# ### Вывод

# Так как в 2174 из 21525 строках пропущено значение о трудовом стаже в днях в столбце ['days_employed'] и ['total_income'], а это 4,7% от всех значений. Это количество не такое большое. Также мы не можем получить недостающие данные  о трудовом стаже и доходе. Эти значения можем удалить,а столбец ['days_employed'] убрать вовсе, чтобы не портили таблицу. Было замечено, что значения пропущены как в столбце ['days_employed'] так  и в столбце ['total_income'], причем с одинаковым индексом.
# Возможные причины появления пропусков связяны с тем, что клиент не помнит свой трудовой стаж или он просто не работает, а про тип занятости мог соврать. Скорее всего эти пропуски не связяны с техническими проблемами, а человеческий фактор.
# 
# # В ходе обработки пропусков был удален столбец по стажу работы, т.к он не нужен для анализа. Пропуски по доходу были заменены на средние значения дохода по соответствующему роду деятельности.

# ### Замена типа данных

# In[15]:


data['total_income']=data['total_income'].astype('int64') #переводим вещественный тип в целоцисленный


# In[16]:


data.info()


# ### Вывод

# В столбце ['total_incom']  тип тоже был поменян с вещественного на целочисленный. Так просто приятнее на них смотреть.

# <font color='blue'>Тип данных изменен - это важный шаг.</font>

# ### Обработка дубликатов

# In[17]:


data['education'].value_counts() # количество дубликатов в столбце ['education']


# In[18]:


data['education']=data['education'].str.lower() # приводим таблицу к нижнему регистру 


# In[19]:


data['education'].value_counts()


# In[20]:


data.duplicated().sum()# Поиск дубликатов


# In[21]:


data=data.drop_duplicates().reset_index(drop= True)# удаляем все дубликаты


# In[22]:


data.duplicated().sum() #еще раз проверяем. Дубликатов нет


# ### Вывод

# Дубликаты были в столбце ['education'] и отличались они только регистром. Поэтому я воспользовался функцией str.lower() и понизил весь текст по регистру. После этого ушли все дубликаты в столбце ['education']

# <font color='blue'> Дубликаты по факту не удалены. Кроме переведения к нижнему регистру, здесь нужно посчитать количество дубликатов, удалить и еще раз посчитать (получить 0)</font>

# ### Лемматизация

# In[23]:


m=Mystem() # присваиваем m библиотеку pymystem3 для лемматизации


# In[24]:


data['purpose'].value_counts() # уникальные цели 


# Из этого списка уникальных целей выделяем 4 основные группы: недвижимость, автомобиль, образование, личные цели 

# In[25]:


#В функцию lemmatization аргументом попадает цель purpose. Затем в lemma_tmp списов 
#лемматизарованых значений с помощию функции limmatize. Группа условий проверяет lemma_tmp и 
#определяет ее в одну из четырех: жилье, автомобиль, образование, личные цели.

def lemmatization (purpose):
    
    lemma_tmp=m.lemmatize(purpose)
              
    if ('жилье' in lemma_tmp) or ('недвижимость' in lemma_tmp):
        lemma_name_purpose='жилье'
        return lemma_name_purpose
    elif 'автомобиль' in lemma_tmp:
        lemma_name_purpose='автомобиль'
        return lemma_name_purpose
    elif 'образование' in lemma_tmp:
        lemma_name_purpose='образование'
        return lemma_name_purpose
    else:
        lemma_name_purpose='личные цели'
        return lemma_name_purpose


# In[26]:


purp_lem=data['purpose'].apply(lemmatization) # Функция apply все значения закидывает в 
#функцию limmatization и присваивает purp_lem


# In[27]:


data['purpose']=purp_lem #присваеваем переменную с леммами столбцу ['purpose'] 


# In[28]:


data.head(5)


# После лемматизации столбец выглядит понятнее, видно 4 категории целей, которыу можно удобно группировать и исследовать

# <font color='blue'> Лемматизация была выполнена - это самая сложная часть проекта. Заодно и категоризация начата, это можно было отнести на следующий шаг.</font>

# # Убираем артифакты

# In[29]:


data['gender'].value_counts()


# In[30]:


data=data.drop(data[data['gender']=='XNA'].index) #удаляем в столбце {'gender'} значение XNA


# In[31]:


data['gender'].value_counts()


# In[32]:


data['children'].value_counts()


# In[33]:


data['children']=data['children'].replace(-1,1) # заменяем знечение в столбце ['children'] -1 на 1 и 20 на 2. 
data['children']=data['children'].replace(20,2) # скорее всего это были неправильно занесенные данные


# In[34]:


data['children'].value_counts() # Теперь данные хорошие


# In[35]:


data['dob_years'].unique() 


# In[36]:


data=data.drop(data[data['dob_years']==0].index) # Удаляем в столбце возраст значение 0. Оно явно ошибочное. 


# In[37]:


data['dob_years'].unique()


# ### Категоризация данных

# In[38]:


data.set_axis(['children(количество детей)','dob_years(возраст)','education(образование)','education_id','family_status(семейный статус)','family_status_id','gender(пол)','income_type(род деятельности)','debt(просрочки)','total_income(уровень дохода)','purpose(цель кредита)'],axis='columns',inplace=True) # меняем название столбцов


# In[39]:


data.head(5)


# In[40]:


data.sort_values(by='dob_years(возраст)') # сортируем по столбцу возраст по возрастанию


# Возраст варьируется от 19 до 75 лет.

# Категоризируем на возрастные группы:

# In[41]:


# Функция для разбивки на категории в зависимости от возраста.
def dob_years_group(age):
    if 19<=age<=35:
        return 'молодые'
    if 36<age<59:
        return 'взрослые'
    return 'пенсионеры'


# In[46]:


dob_years_group(60) # проверочка!!!


# In[41]:


dob_years_group=data['dob_years(возраст)'].apply(dob_years_group)


# In[42]:


data['dob_years(возраст)']=dob_years_group
data


# In[43]:


data.sort_values(by='total_income(уровень дохода)')


# Уровень дохода лужит в промежутке от 20 тр руб и до 2.26 млн руб.

# In[44]:


# Функция для категоризации по уровню дохода
def total_income_group(income):
    if 20000<=income<70000:
        return "низкий доход"
    if 70001<=income<120000:
        return 'средний доход'
    if 120001<=income<200000:
        return 'высокий доход'
    return 'очень высокий доход'


# In[1]:


total_income_group(70000)


# In[45]:


total_income_gr=data['total_income(уровень дохода)'].apply(total_income_group)


# In[46]:


data['total_income(уровень дохода)']=total_income_gr
data.head(10)


# ### Вывод

# В процессе категоризации были выбраны две группы, которые я разбивал на категории. Это столбец Возраст и столбец Доход. Категоризация проходила с помощью функиции с группой условий и метода apply. Эти столбцы были выбраны для категоризации, т.к. они используются в дальнейшем исследовании и это очень удобный вид для представления этих данных

# <font color='blue'> категоризация выполнена технически хорошо.</font>

# ### Шаг 3. Ответьте на вопросы

# - Есть ли зависимость между наличием детей и возвратом кредита в срок?

# <font color='blue'> Здесь нужно найти не количество неплатильщиков, а вероятность невыплаты кредита. Т.е. поделить число неплатильщиков без детей на общее число кредиторов без детей. </font>

# In[47]:


chil_debt=data.groupby('children(количество детей)').agg({'debt(просрочки)':['count','sum']}) # агрегированная функция


# In[48]:


chil_debt


# In[49]:


chil_quality=chil_debt['debt(просрочки)']['sum']/chil_debt['debt(просрочки)']['count']


# In[50]:


chil_quality # Подсет доли


# ### Вывод

# Из этих данных видно, что возврат кредит связан с количеством детей. Больше всего просрочек у людей с 1, 2,3,4 детьми. Нет росрочек в тех у кого 5 детей. У кого их вообще нет- просрочек меньше. Скорее всего это связано с финансовой нагрузкой

# - Есть ли зависимость между семейным положением и возвратом кредита в срок?

# In[51]:


family_grouped=data.groupby('family_status(семейный статус)').agg({'debt(просрочки)':['count','sum']}) 
family_debt_quality=family_grouped['debt(просрочки)']['sum']/family_grouped['debt(просрочки)']['count']


# In[52]:


family_debt_quality


# Посчитали долю просрочек по кредиту в зависимости от статуса человека. Сумму и количество посчитали с помощью гуппивки и метода count и sum в agg()

# <font color='blue'> Вот здесь правильно </font>

# ### Вывод

# На основании среза данных "семейный статус" и "просрочек по кредиту", можно увидеть интересные данные:
# - Люди, которые были в официальных отношениях, а теперь по-одиночке имеют меньше просрочек по кредиту. Это видно на примере данных "вдовец/вдова"- доля просрочек на всех "вдовцов/вдов" составляет- 0.06. Похожие результаты можно увидеть и у людей, которые в "разводе". Доля просрочек на всех разведенных составляет - 0.07. Я это могу объяснить тем, что человек, который был в официальном браке, а в дальнейшем развелся или потерял мужа/жену, инеет высокий уровень ответственности. В их жизни приходилось принимать серьезные решения.  
# -  Доля просрочек на всех женатых/ замужем составляет- 0.075, но и этот показатель не самых плохой. Можно сказать, что доля просрочек у "женат / замужем" и в "разводе" почти одинакова;
# - Что касается людей в "гражданском браке" и "не женатых / не замужем", то тут самый плохой показатель. Хуже всего этот показатель у "не женат / не замужем"- доля просрочек - 0.1. Думаю, что это связано с тем, что человек не готов к серьезному развитию (отсутствие семьи), а значит нет желания брать ответственность. Кредитную тоже!
# 

# - Есть ли зависимость между уровнем дохода и возвратом кредита в срок?

# In[53]:


total_income_grouped=data.groupby('total_income(уровень дохода)').agg({'debt(просрочки)':['sum','count']})
total_income_quality=total_income_grouped['debt(просрочки)']['sum']/total_income_grouped['debt(просрочки)']['count']


# In[54]:


total_income_grouped['debt(просрочки)']


# In[55]:


total_income_quality


# Посчитали долю просрочек по кредиту в зависимости от дохода. Сумму и количество посчитали с помощью гуппивки и метода count и sum в agg()

# In[56]:


data_pivot=data.pivot_table(index=['dob_years(возраст)'],columns='total_income(уровень дохода)',values='debt(просрочки)',aggfunc='sum')
data_pivot


# Сводная таблица просрочкам кредита в зависимости от возраста и уровня дохода. Тут можно увидеть какой возраст имеет больше всего просрочек.

# In[57]:


data_pivot=data.pivot_table(index=['income_type(род деятельности)','dob_years(возраст)'],columns='total_income(уровень дохода)',values='debt(просрочки)',aggfunc='sum')


# In[58]:


data_pivot


# Сводная таблица просрочек по кредиту в зависимости от трудового стажа, возраста и дохода. Можно видеть,что много просрочек по кредиту у служащих молодых и взрослых.
На основании среза данных по уровню дохода и количеством просрочек по кредитам, можно сделать следующие выводы:
- Люди с низким доходом (от 20 до 70 тр. руб) имеют меньше просрочек по кредитам( доля просрочек- 0.069). Почти такой же показатель (доля 0.07) и у людей с очень высоким доходом (больше 200 тр. руб.). Что касается людей с низким доходом. Это можно объяснить тем, что кредит для них ценнен. Имея низкий доход, они взяли кредит на то, что действительно важно и понимают, что важно не портить кредитную историю для будующего кредита. Что касается людей с очень высоким уровнем дохода, то это можно объяснить тем, что они понимают ценность денег. И выплата кредита не сильно "бьет по кошельку". А возможно их доход связан с деньгами от прошлых кредитов, поэтому нет желания портить кредитную историю.
- Плохая исторяи у людей со средним уровнем дохода (от 70 до 120 тр. руб.). Тут доля получается 0.084. В этой категории много молодых людей с просрочкой(182 чел.), чья ответственность возможно под вопросом.
- Самая плохая история по просрочкам у категории с высоким доходом (от 120 до 200 тр. руб.). Тут доля просрочек получается 0.09. Также в этой группе присутствут много молодых (283 чел.) и много взрослых (303 чел). Могу предположить луди этой категории относятся в кредитным деньгам не серьезно. Есть понимание, что могут его сразу закрыть. По роду деятельности в основном это служащие. 
# ### Вывод

# - Как разные цели кредита влияют на его возврат в срок?

# In[59]:


purpose_grouped=data.groupby('purpose(цель кредита)').agg({'debt(просрочки)':['sum','count']})
purpose_convers=purpose_grouped['debt(просрочки)']['sum']/purpose_grouped['debt(просрочки)']['count']
purpose_convers


# Посчитали долю просрочек по кредиту в зависимости от цели кредита. Сумму и количество посчитали с помощью гуппивки и метода count и sum в agg()

# ### Вывод

# Из полученных данных среза "цель кредита и просрочи можно сделать вывод, что:
# - больше всего просрочек у кредитов на автомобиль и образование. Доля их получается 0.092. Можно это объяснить тем, что на рынке автокредитования создаются очень привлекательные предложения и человек порой берет кредит не оценевая аддекватно свои возможности.  
# - Кредит на личные цели и кредит на недвижимось имеют меньше просрочек. Человек, выбирая ипотеку, хорошо просчитывает свои возможности, так как срок платежа очень большой. 

# ### Шаг 4. Общий вывод

# Из моих данных я могу сделать вывод, что самыми надежными заемщиками являются люди, которые берут ипотеку, с низким или очень высоким уровнем заработка, имеющие детей (чем больше, тем лучше), состоящие в официальном браке(лучше вдовец или вдова)

# <font color='blue'> Проект выполнен на хорошем уровне, но постарайся доработать по замечаниям. </font>

# <font color='red'> Проект хорошо доработан

# ### Чек-лист готовности проекта
# 
# Поставьте 'x' в выполненных пунктах. Далее нажмите Shift+Enter.

# - [x]  открыт файл;
# - [x]  файл изучен;
# - [x]  определены пропущенные значения;
# - [x]  заполнены пропущенные значения;
# - [x]  есть пояснение какие пропущенные значения обнаружены;
# - [x]  описаны возможные причины появления пропусков в данных;
# - [x]  объяснено по какому принципу заполнены пропуски;
# - [x]  заменен вещественный тип данных на целочисленный;
# - [x]  есть пояснение какой метод используется для изменения типа данных и почему;
# - [x]  удалены дубликаты;
# - [x]  есть пояснение какой метод используется для поиска и удаления дубликатов;
# - [x]  описаны возможные причины появления дубликатов в данных;
# - [x]  выделены леммы в значениях столбца с целями получения кредита;
# - [x]  описан процесс лемматизации;
# - [x]  данные категоризированы;
# - [x]  есть объяснение принципа категоризации данных;
# - [x]  есть ответ на вопрос "Есть ли зависимость между наличием детей и возвратом кредита в срок?";
# - [x]  есть ответ на вопрос "Есть ли зависимость между семейным положением и возвратом кредита в срок?";
# - [x]  есть ответ на вопрос "Есть ли зависимость между уровнем дохода и возвратом кредита в срок?";
# - [x]  есть ответ на вопрос "Как разные цели кредита влияют на его возврат в срок?";
# - [x]  в каждом этапе есть выводы;
# - [x]  есть общий вывод.

# In[ ]:





# In[ ]:





# In[ ]:




